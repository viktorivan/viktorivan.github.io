<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c++ | Iván Rodríguez]]></title>
  <link href="http://viktorivan.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://viktorivan.github.io/"/>
  <updated>2015-11-09T16:29:56-06:00</updated>
  <id>http://viktorivan.github.io/</id>
  <author>
    <name><![CDATA[Iván Rodríguez]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bloques de procesamiento de señales en GNU Radio]]></title>
    <link href="http://viktorivan.github.io/blog/2014/03/19/bloques-de-procesamiento-de-senales-en-gnu-radio/"/>
    <updated>2014-03-19T13:06:58-06:00</updated>
    <id>http://viktorivan.github.io/blog/2014/03/19/bloques-de-procesamiento-de-senales-en-gnu-radio</id>
    <content type="html"><![CDATA[<p>Introducción.</p>

<p>El proyecto de <a href="http://www.gnuradio.org">GNU Radio</a> permite el desarrollo de bloques de procesamiento de señales que pueden ser escritos tanto en lenguaje de programación Python o C++. Este tipo de módulos son conocidos como <code>out-of-tree</code>, ya que, aunque los módulos serán integrados dentro del catálogo de bloques de GNU Radio no se van a integrar al proyecto para su distribución.</p>

<!-- more -->

<p>Procedimiento.</p>

<p>Para crear un módulo out-of-tree se ejecuta desde una terminal de linux el siguiente comando</p>

<p><code>
$ gr_modtool create
Name of the new module:Tu_modulo
Creating out-of-tree module in ./gr-Tu_modulo... Done. 
Use 'gr_modtool add' to add a new block to this currently empty module. 
</code></p>

<p>El nombre que se indique para el módulo es con el que va a aparecer en el catálogo de GNU Radio.</p>

<p>Para crear los bloques que integrarán el módulo se utiliza la herramienta <code>gr_modtool</code> en la carpeta raíz del proyecto. En este caso se creará un bloque que realizará la función de un convertidor binario a decimal para los tipos de datos float.</p>

<p><code>
$ cd gr-Tu_modulo
$ gr_modtool add
GNU Radio module name identified: Tu_modulo 
Enter code type: decimator 
Language: C++ 
Enter name of block/code (without module name prefix): bin2dec_ff 
Block/code identifier: bin2dec_ff 
Enter valid argument list, including default arguments: int vec_size 
Add Python QA code? [Y/n] 
Add C++ QA code? [y/N] 
Adding file 'lib/bin2dec_ff_impl.h'... 
Adding file 'lib/bin2dec_ff_impl.cc'... 
Adding file 'include/Tu_modulo/bin2dec_ff.h'... 
Editing swig/Tu_modulo_swig.i... 
Adding file 'python/qa_bin2dec_ff.py'... 
Editing python/CMakeLists.txt... 
Adding file 'grc/Tu_modulo_bin2dec_ff.xml'... 
Editing grc/CMakeLists.txt...
</code>
y a su vez, se desarrollará un bloque que realice la operación inversa, esto es, un convertidor decimal a binario.</p>

<p><code>
$ gr_modtool add 
GNU Radio module name identified: Tu_modulo 
Enter code type: interpolator 
Language: C++ 
Enter name of block/code (without module name prefix): dec2bin_ff 
Block/code identifier: dec2bin_ff 
Enter valid argument list, including default arguments: int vec_size 
Add Python QA code? [Y/n] 
Add C++ QA code? [y/N] 
Adding file 'lib/dec2bin_ff_impl.h'... 
Adding file 'lib/dec2bin_ff_impl.cc'... 
Adding file 'include/Tu_modulo/dec2bin_ff.h'... 
Editing swig/Tu_modulo_swig.i... 
Adding file 'python/qa_dec2bin_ff.py'... 
Editing python/CMakeLists.txt... 
Adding file 'grc/Tu_modulo_dec2bin_ff.xml'... 
Editing grc/CmakeLists.txt...
</code></p>

<p>de esta manera se han creado dos bloques, un decimador para el convertidor binario a decimal y un interpolador para el decimal a binario.</p>

<p>Los archivos donde se realizará la programación en código c++ se ubican en <code>~/gr-Tu_modulo/lib</code> y se llama <code>dec2bin_ff_impl.cc</code> para el convertidor decimal a binario y <code>bin2dec_ff_impl.cc</code> para el convertidor binario a decimal.</p>

<p><em>Convertidor binario a decimal</em></p>

<p>Dentro del archivo <code>bin2dec_ff_impl.cc</code> hay que indicar las librerías que se utilizarán, en este caso sólo requerimos la librería <code>math.h</code>, después de los include ya definidos agregamos:</p>

<pre><code>#include &lt;math.h&gt;
</code></pre>

<p>En la sección de <code>bin2dec_ff_impl::bin2dec_ff_impl(int vec_size)</code> se definen la cantidad de flujos de datos que manejará el bloque de procesamiento, en este caso, sólo es un flujo de entrada y uno de salida, el factor de decimación definido por la variable vec_size y además se asigna a la variable chunk el valor de vec_size, ya que vec_size representa la cantidad de bits que se requieren para convertir el número a decimal. </p>

<pre><code>bin2dec_ff_impl::bin2dec_ff_impl(int vec_size)
  : gr::sync_decimator("bin2dec_ff",
          gr::io_signature::make(1, 1, sizeof(float)),
          gr::io_signature::make(1, 1, sizeof(float)), vec_size)
{
	chunk = vec_size;
}
</code></pre>

<p>En la parte correspondiente a <code>// Do &lt;+signal processing+&gt;</code> es donde se realiza el procesamiento de datos que manipulará el bloque, para la conversión de binario a decimal se desarrolla el código de programación en C++, quedando de la siguiente manera:</p>

<pre><code>int
bin2dec_ff_impl::work(int noutput_items,
		  gr_vector_const_void_star &amp;input_items,
		  gr_vector_void_star &amp;output_items)
{
    const float *in = (const float *) input_items[0];
    float *out = (float *) output_items[0];

    int j = 0, a = 0;
    for (int i = 0; i &lt; noutput_items * chunk; i = i + chunk){
    	out[j] = 0;
    	a = chunk - 1;
    	for (int k = 0; k &lt; chunk; k++){
    		out[j] = out[j] + (in[i + k] * pow (2,a));
    		a = a - 1;
    	}
    	j++;
    }

    // Tell runtime system how many output items we produced.
    return noutput_items;
}
</code></pre>

<p>El archivo quedaría de la siguiente forma, ya con todas las modificaciones incluidas:</p>

<p>{% include_code bin2dec_ff_impl.cc bin2dec_ff_impl.cpp %}</p>

<p><em>Convertidor decimal a binario</em></p>

<p>Para corroborar el correcto funcionamiento del bloque de convertidor binario a decimal se propone realizar un convertidor decimal a binario que realizará la operación inversa del bloque anterior.</p>

<p>El archivo donde se realiza la programación es <code>dec2bin_ff_impl.cc</code>. Como primer paso se indica la librería que utilizará el bloque de procesamiento, de la misma forma que se indicó en el bloque anterior.</p>

<pre><code>#include &lt;math.h&gt;
</code></pre>

<p>Nuevamente, en la sección de <code>dec2bin_ff_impl::dec2bin_ff_impl(int vec_size)
</code> se indica la cantidad de flujos de entrada y salida que manejará el bloque de procesamiento, así también el factor de interpolación definido por la variable vec_size y por último la variable chunk, quedando como sigue:</p>

<pre><code>dec2bin_ff_impl::dec2bin_ff_impl(int vec_size)
  : gr::sync_interpolator("dec2bin_ff",
          gr::io_signature::make(1, 1, sizeof(float)),
          gr::io_signature::make(1, 1, sizeof(float)), vec_size)
{
	chunk = vec_size;
}
</code></pre>

<p>En la sección de <code>// Do &lt;+signal processing+&gt;</code> se escribe el código que realizará la conversión decimal a binario.</p>

<pre><code>int
dec2bin_ff_impl::work(int noutput_items,
		  gr_vector_const_void_star &amp;input_items,
		  gr_vector_void_star &amp;output_items)
{
    const float *in = (const float *) input_items[0];
    float *out = (float *) output_items[0];

    int l = 0, m = 0, a = 0, b[chunk];
    for (int i = 0; i &lt; noutput_items / chunk; i++){
    	a = in[i];
    	l = chunk - 1;
    	for (int j = 0; j &lt; chunk; j++){
    		b[j] = a % 2;
    		a = a / 2;	
    	}
    	for (int k = 0; k &lt; chunk; k++){
    		out[m] = b [l];
    		l = l - 1;
    		m++;
    	}
    }
</code></pre>

<p>El archivo completo queda de la siguiente manera:</p>

<p>{% include_code dec2bin_ff_impl.cc dec2bin_ff_impl.cpp %}</p>

<p>Adicionalmente hay que declarar la variable <code>chunk</code> de tal forma que sea pública y poder utilizarla en las diferentes secciones del bloque de procesamiento, esto se hace modificando el archivo <code>bin2dec_ff_impl.h</code> para el convertidor binario a decimal y el archivo <code>dec2bin_ff_impl.h</code> para el convertidor decimal a binario. En la sección de <code>public</code> se agrega:</p>

<pre><code> public:
  bin2dec_ff_impl(int vec_size);
  int chunk;
  ~bin2dec_ff_impl();
</code></pre>

<p>Quedando los archivos como siguen</p>

<p>{% include_code bin2dec_ff_impl.h bin2dec_ff_impl.c %}</p>

<p>{% include_code dec2bin_ff_impl.h dec2bin_ff_impl.c %}</p>

<p><em>Interfaz GNU Radio Companion</em></p>

<p>Los bloques dentro de GNU Radio Companion (GRC) son archivos xml que se ubican en <code>~/gr-Tu_modulo/grc</code>, para el convertidor binario a decimal se llama <code>Tu_modulo_bin2dec_ff.xml</code> y para el convertidor decimal a binario <code>Tu_modulo_dec2bin_ff.xml</code>.</p>

<p>Dentro del archivo xml hay varios parámetros que pueden ser personalizados, tal como el nombre del bloque, este parámetro se define en la línea correspondiente a <code>&lt;name&gt;</code>.</p>

<pre><code>&lt;name&gt;Binary To Decimal&lt;/name&gt;
</code></pre>

<p>En la parte de <code>&lt;param&gt;</code> se indica la variable de entrada del bloque</p>

<pre><code>  &lt;param&gt;
    &lt;name&gt;Vector size&lt;/name&gt;
    &lt;key&gt;vec_size&lt;/key&gt;
    &lt;type&gt;int&lt;/type&gt;
  &lt;/param&gt;
</code></pre>

<p>El conector de entrada del bloque de procesamiento se define en <code>&lt;sink&gt;</code></p>

<pre><code>  &lt;sink&gt;
    &lt;name&gt;in&lt;/name&gt;
    &lt;type&gt;float&lt;/type&gt;
  &lt;/sink&gt;
</code></pre>

<p>El conector de salida en <code>&lt;source&gt;</code></p>

<pre><code>  &lt;source&gt;
    &lt;name&gt;out&lt;/name&gt;
    &lt;type&gt;float&lt;/type&gt;
  &lt;/source&gt;
</code></pre>

<p>De igual manera se modifican las secciones de <code>&lt;name&gt;</code>, <code>&lt;param&gt;</code>, <code>&lt;sink&gt;</code> y <code>&lt;source&gt;</code> en el archivo <code>Tu_modulo_dec2bin_ff.xml</code> para el bloque de procesamiento del convertidor decimal a binario.</p>

<p>Los archivos quedarán finalmente de la siguiente forma:</p>

<p>{% include_code  Tu_modulo_bin2dec_ff.xml %}</p>

<p>{% include_code  Tu_modulo_dec2bin_ff.xml %}</p>

<p><em>Compilación de los bloques</em></p>

<p>Una vez ya realizado todos los procesos referentes al código de programación de los bloques de procesamiento se procede a integrarlos en el proyecto de GNU Radio. Esto se realiza por medio de una serie de comandos desde una terminal de linux en la raíz del proyecto. En caso de no tener una carpeta de build, se crea por medio de comandos de linux</p>

<p><code>
$ mkdir build
$ cd build
</code>
Una vez dentro de la carpeta de build, se procede a compilar el proyecto</p>

<p><code>
$ cmake ../
$ make
$ sudo make install
$ sudo ldconfig
</code>
De esa manera queda integrado el módulo out-of-tree dentro de GNU Radio.</p>

<p>viktorivan@openmailbox.org</p>

<p>@viktor_ivan</p>
]]></content>
  </entry>
  
</feed>
