<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://viktorivan.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://viktorivan.github.io/" rel="alternate" type="text/html" /><updated>2018-04-11T01:09:01+00:00</updated><id>http://viktorivan.github.io/</id><title type="html">Iván Rodríguez</title><subtitle>Un blog sobre radio definido por software.</subtitle><entry><title type="html">Instalación De ADI Linux Embedded De Analog Devices</title><link href="http://viktorivan.github.io/adi/linux-embedded/analog-devices/picozed/zedboard/2016/11/01/instalacin-de-adi-linux-embedded-de-analog-devices.html" rel="alternate" type="text/html" title="Instalación De ADI Linux Embedded De Analog Devices" /><published>2016-11-01T22:06:17+00:00</published><updated>2016-11-01T22:06:17+00:00</updated><id>http://viktorivan.github.io/adi/linux-embedded/analog-devices/picozed/zedboard/2016/11/01/instalacin-de-adi-linux-embedded-de-analog-devices</id><content type="html" xml:base="http://viktorivan.github.io/adi/linux-embedded/analog-devices/picozed/zedboard/2016/11/01/instalacin-de-adi-linux-embedded-de-analog-devices.html">&lt;p&gt;El desarrollo de sistemas operativos embebidos personalizados permite a los fabricantes de hardware tener un ecosistema de programación con las herramientas y drivers necesarios para la implementación rápida de sistemas de comunicación en sus plataformas de evaluación.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.analog.com&quot;&gt;Analog Devices&lt;/a&gt; ha desarrollado un sistema operativo (ADI) que contiene un entorno de programación para aplicaciones basadas en SDR capaz de conectarse a una red para acceso y control remoto.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Descarga de ADI.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;La imágen de ADI se encuentra en la página de &lt;a href=&quot;https://wiki.analog.com/resources/tools-software/linux-software/zynq_images&quot;&gt;Zynq &amp;amp; Altera SoC Quick Start Guide&lt;/a&gt;, en ella se pueden descargar diferentes versiones de ADI, también se puede observar una lista de las plataformas compatibles con el sistema operativo.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instalación de ADI en la memoria SD.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;De acuerdo a la página de &lt;a href=&quot;https://wiki.analog.com/resources/tools-software/linux-software/zynq_images/linux_hosts&quot;&gt;Linux Download and setting up the image&lt;/a&gt;, primero se descomprime el archivo descargado de la imágen de ADI.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ unxz 2014_R2-2015_02_06.img.xz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;El archivo extraído tiene terminación &lt;code class=&quot;highlighter-rouge&quot;&gt;img&lt;/code&gt;, el cual es una imágen del sistema operativo que se copiará en la memoria SD.&lt;/p&gt;

&lt;p&gt;Con el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo dd&lt;/code&gt; se copiará la imágen en la memoria SD, para ello se debe conocer la ubicación y desmontar la memoria SD. Este proceso de escritura suele tardar varios minutos.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ lsblk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo umount /dev/mmcblk0p1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo dd if=2014_R2-2015_02_06.img of=/dev/mmcblk0 bs=4194304
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Para evitar algún tipo de error al momento de retirar la memoria SD, se recomienda limpiar los buffers del sistema, esto se hace con el siguiente comando.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sync
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Configuración de tarjeta de evaluación.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Una vez preparada la memoria SD, se procede con la configuración de los jumpers de la tarjeta de evaluación de acuerdo a la siguiente &lt;a href=&quot;https://wiki.analog.com/_detail/resources/eval/user-guides/ad-fmcomms2-ebz/quickstart/zed_sw.jpg?id=resources%3Aeval%3Auser-guides%3Aad-fmcomms2-ebz%3Aquickstart%3Azynq&quot;&gt;imágen&lt;/a&gt;, de este modo se le indicará que existe un sistema operativo y que está ubicado en la ranura de la memoria SD. En la página de &lt;a href=&quot;https://wiki.analog.com/resources/eval/user-guides/ad-fmcomms2-ebz/quickstart/zynq&quot;&gt;AD-FMCOMMS2/3/4/5-EBZ Zynq and ZED Quick Start Guide&lt;/a&gt; se puede observar a detalle los pasos a seguir.&lt;/p&gt;

&lt;p&gt;Finalmente, la tarjeta de evaluación funciona con un sistema operativo embebido, el cual puede ser utilizado con un monitor HDMI y teclado o remotamente a través de &lt;code class=&quot;highlighter-rouge&quot;&gt;SSH&lt;/code&gt; o &lt;code class=&quot;highlighter-rouge&quot;&gt;VNC&lt;/code&gt; conectado a la red.&lt;/p&gt;

&lt;p&gt;Por defecto, el sistema operativo tiene habilitado el puerto &lt;code class=&quot;highlighter-rouge&quot;&gt;SSH&lt;/code&gt;, y los usuarios son: &lt;code class=&quot;highlighter-rouge&quot;&gt;analog&lt;/code&gt; con contraseña &lt;code class=&quot;highlighter-rouge&quot;&gt;analog&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; con contraseña &lt;code class=&quot;highlighter-rouge&quot;&gt;analog&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh -X analog@dirección-ip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;La opción &lt;code class=&quot;highlighter-rouge&quot;&gt;-X&lt;/code&gt; es opcional y sirve para habilitar el modo gráfico desde la terminar &lt;code class=&quot;highlighter-rouge&quot;&gt;SSH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Para habilitar el escritorio remoto de &lt;code class=&quot;highlighter-rouge&quot;&gt;VNC&lt;/code&gt;, se debe de ejecutar el comando de &lt;code class=&quot;highlighter-rouge&quot;&gt;vino-preferences&lt;/code&gt; desde una terminal, en caso de que no se haya indicado la opción &lt;code class=&quot;highlighter-rouge&quot;&gt;-X&lt;/code&gt; al conectarse por &lt;code class=&quot;highlighter-rouge&quot;&gt;SSH&lt;/code&gt; este desplegará un error.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo vino-preferences
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Aunque la ventana de &lt;code class=&quot;highlighter-rouge&quot;&gt;vino-preferences&lt;/code&gt; no actualice en tiempo real, los cambios se pueden verificar cerrando la ventana y ejecutando el comando nuevamente.&lt;/p&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name></name></author><summary type="html">El desarrollo de sistemas operativos embebidos personalizados permite a los fabricantes de hardware tener un ecosistema de programación con las herramientas y drivers necesarios para la implementación rápida de sistemas de comunicación en sus plataformas de evaluación.</summary></entry><entry><title type="html">Compilación Cruzada De GNU Radio Y Proyectos OOT en Linux Embebido</title><link href="http://viktorivan.github.io/gnuradio/cross-compiling/linux-embedded/2016/10/28/compilacin-cruzada-de-gnu-radio-y-proyectos-oot-en-linux-embebido.html" rel="alternate" type="text/html" title="Compilación Cruzada De GNU Radio Y Proyectos OOT en Linux Embebido" /><published>2016-10-28T15:23:44+00:00</published><updated>2016-10-28T15:23:44+00:00</updated><id>http://viktorivan.github.io/gnuradio/cross-compiling/linux-embedded/2016/10/28/compilacin-cruzada-de-gnu-radio-y-proyectos-oot-en-linux-embebido</id><content type="html" xml:base="http://viktorivan.github.io/gnuradio/cross-compiling/linux-embedded/2016/10/28/compilacin-cruzada-de-gnu-radio-y-proyectos-oot-en-linux-embebido.html">&lt;p&gt;El uso de sistemas embebidos se ha popularizado debido a que permiten implementar sistemas para un uso específico utilizando un entorno amigable de programación. Existen sistemas muy populares como &lt;a href=&quot;https://www.raspberrypi.org/&quot;&gt;Raspberry Pi&lt;/a&gt; de bajo costo, pero hay otros sistemas con un grado de especialización mayor, como es el caso de &lt;a href=&quot;http://zedboard.org/&quot;&gt;Zedboard&lt;/a&gt;, el cual permite la implementación de aceleradores de hardware e integración con dispositivos de comunicación reconfigurable.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Compilación Cruzada.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El término de compilación cruzada se refiere al proceso de compilación de los archivos para el sistema operativo basado en ARM, utilizando una computadora con un procesador diferente. De este modo, aprovechando el poder de cómputo de una computadora personal es posible generar los archivos que se utilizarán en el sistema embebido, la ventaja principal de la compilación cruzada es la reducción del tiempo que se requiere para instalar aplicaciones si se utilizara en cambio el procesador ARM.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GNU Radio Embedded.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Existen diferentes sistemas operativos embebedidos, ya sea basados en &lt;a href=&quot;https://developer.microsoft.com/en-us/windows/iot&quot;&gt;Windows&lt;/a&gt;, &lt;a href=&quot;https://source.android.com/&quot;&gt;Android&lt;/a&gt; o &lt;a href=&quot;http://elinux.org/&quot;&gt;Linux&lt;/a&gt;, los cuales permiten la interacción y control de la plataforma de hardware a través de protolos como &lt;code class=&quot;highlighter-rouge&quot;&gt;SSH&lt;/code&gt; o &lt;code class=&quot;highlighter-rouge&quot;&gt;Escritorio Remoto&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;En el caso de Linux Embedded, existen herramientas que permiten generar una versión personalizada del sistema operativo, tal como &lt;a href=&quot;https://www.yoctoproject.org/&quot;&gt;Yocto&lt;/a&gt; y &lt;a href=&quot;http://openembedded.org/&quot;&gt;Open Embedded&lt;/a&gt;, donde, a través de selección de capas (layers), el usuario puede escoger las aplicaciones que se descargarán y compilarán para generar el sistema operativo embebido.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://gnuradio.org/redmine/projects/gnuradio/wiki/Embedded&quot;&gt;GNU Radio Embedded&lt;/a&gt; es un desarrollo del proyecto de &lt;a href=&quot;http://gnuradio.org/&quot;&gt;GNU Radio&lt;/a&gt; donde, con ayuda de Open Embedded, se crea un sistema operativo embebido personalizado que incluye las herramientas de GNU Radio, adicionalmente, incluye un Software Development Kit (SDK) para actualizar las librerías y programas de GNU Radio a través de compilación cruzada.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instalación de GNU Radio con compilación cruzada.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instalación de SDK de GNU Radio.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Previo a la descarga del proyecto que se instalará a través de compilación cruzada, se requiere de la instalación del SDK (Software development Kit) de GNU Radio, en el post de &lt;a href=&quot;/gnuradio/embedded/zedboard/2015/11/28/instalacion-de-gnu-radio-embedded-en-tarjetas-zedboard.html&quot;&gt;Instalación de GNU Radio embedded en tarjetas ZedBoard&lt;/a&gt; se indica como instalar el SDK.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Descarga de proyecto de GNU Radio.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El proyecto de GNU Radio se puede descargar a través de sus repositorios con la herramienta de git.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone --recursive http://git.gnuradio.org/git/gnuradio.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Al terminar, se creará una carpeta que contendrá el proyecto recién descargado, dentro esta carpeta se requiere ejecutar el comando que habilitará el entorno del SDK para la compilación cruzada.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd gnuradio
$ . /usr/local/oecore-x86_64/environment-setup-armv7ahf-vfp-neon-oe-linux-gnueabi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Una vez habilitado el entorno, se procede a la generación de los archivos compatibles con el sistema operativo basado en ARM.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir build-arm
$ cd build-arm
$ cmake -Wno-dev    -DCMAKE_TOOLCHAIN_FILE=/usr/local/src/gnuradio/cmake/Toolchains/oe-sdk_cross.cmake -DENABLE_GR_WXGUI=OFF -DENABLE_GR_VOCODER=OFF -DENABLE_GR_DTV=OFF -DENABLE_GR_ATSC=OFF -DENABLE_DOXYGEN=OFF -DCMAKE_INSTALL_PREFIX=/usr ../
$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Si se desea instalar un proyecto OOT, sólo cambia los parámetros del comando de cmake.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cmake -Wno-dev -DCMAKE_TOOLCHAIN_FILE=/usr/local/src/gnuradio/cmake/Toolchains/oe-sdk_cross.cmake -DENABLE_DOXYGEN=OFF ../
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Una vez terminado este proceso, se copian los archivos generados a la tarjeta SD, en la partición de &lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs&lt;/code&gt;, donde está instalado el sistema operativo embebido.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo make install DESTDIR=ruta-a-memoria-sd/rootfs
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Para actualizar la versión de GNU Radio del SDK, se copian los archivos de GNU Radio en la siguiente ruta.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo make install DESTDIR=/usr/local/oecore-x86_64/sysroots/armv7a-...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Una vez instalado GNU Radio en la memoria SD del sistema operativo embebido, se verifica en con el sistema embebido el correcto funcionamiento del sistema operativo y de GNU Radio.&lt;/p&gt;

&lt;p&gt;Tradicionalmente en GNU Radio se tiene que ejecutar el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo ldconfig&lt;/code&gt; para terminar el proceso de instalación, en el caso de GNU Radio Embebido, desde la terminal remota de SSH o algún cliente remoto, se puede ejecutar este comando para finalizar el proceso de instalación.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ touch /etc/ld.so.conf
$ echo /usr/local/lib &amp;gt;&amp;gt; /etc/ld.so.conf
$ ldconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;En caso de que se hayan instalado paquetes OOT, se tiene que indicar la ubicación de la instalación en la variable &lt;code class=&quot;highlighter-rouge&quot;&gt;PYTHONPATH&lt;/code&gt;, si no se desea estar ejecutando esta variable cada vez que se inicia el sistema operativo, se puede mover los archivos al directorio &lt;code class=&quot;highlighter-rouge&quot;&gt;dist-packages&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export PYTHONPATH=/usr/local/lib/python2.7/site-packages/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Conclusión.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Los sistemas embebidos son sistemas mínimos donde la actualización o instalación de aplicaciones pueden requerir de mucho tiempo o incluso ser un proceso que no se pueda realizar en esa plataforma de hardware. La compilación cruzada es una herramienta que permite ahorrar tiempo en este tipo de operaciones, facilitando al usuario la implementación de programas y eliminando erorres de compilación en la plataforma de hardware embebida.&lt;/p&gt;

&lt;p&gt;GNU Radio en combinación con Linux Embedded nos permite implementar sistemas de radio configurable en plataformas dedicadas de una forma rápida y sencilla, donde con ayuda del SDK es fácil instalar y actualizar los proyectos de GNU Radio.&lt;/p&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name></name></author><summary type="html">El uso de sistemas embebidos se ha popularizado debido a que permiten implementar sistemas para un uso específico utilizando un entorno amigable de programación. Existen sistemas muy populares como Raspberry Pi de bajo costo, pero hay otros sistemas con un grado de especialización mayor, como es el caso de Zedboard, el cual permite la implementación de aceleradores de hardware e integración con dispositivos de comunicación reconfigurable.</summary></entry><entry><title type="html">Instalación De ADI IIO Oscilloscope De Analog Devices en Linux</title><link href="http://viktorivan.github.io/analog-devices/adi/oscilloscope/linux/2016/10/28/instalacin-de-adi-iio-oscilloscope-de-analog-devices-en-linux.html" rel="alternate" type="text/html" title="Instalación De ADI IIO Oscilloscope De Analog Devices en Linux" /><published>2016-10-28T15:16:39+00:00</published><updated>2016-10-28T15:16:39+00:00</updated><id>http://viktorivan.github.io/analog-devices/adi/oscilloscope/linux/2016/10/28/instalacin-de-adi-iio-oscilloscope-de-analog-devices-en-linux</id><content type="html" xml:base="http://viktorivan.github.io/analog-devices/adi/oscilloscope/linux/2016/10/28/instalacin-de-adi-iio-oscilloscope-de-analog-devices-en-linux.html">&lt;p&gt;El desarrollo de plataformas conectadas a la red permite que instrumentos de medición puedan ser controlados remotamente desde una computadora, de este modo, se puede compartir la instrumentación de un laboratorio sin necesidad de moverlo.&lt;/p&gt;

&lt;p&gt;Las tarjetas de evaluación de radio definido por software (SDR) tienen la capacidad de programarse como instrumentos de medición, ya sea como osciloscopio, analizador de espectro o de redes, entre otros. También permiten el monitoreo y control remoto de sus periféricos a través de servicios de su sistema operativo embebido.&lt;/p&gt;

&lt;p&gt;El sistema operativo ADI de Analog Devices incluye un oscisloscopio y analizador de espectro que funciona tanto en la plataforma de SDR como en una computadora, lo que permite al usuario realizar mediciones de zonas remotas sin estar de forma presencial en el laboratorio.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instalación.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El programa de &lt;a href=&quot;https://github.com/analogdevicesinc/iio-oscilloscope&quot;&gt;ADI IIO Oscilloscope&lt;/a&gt; se instala tanto en la plataforma de SDR, el cual está instalado por defecto en ADI Linux Embedded y en la computadora donde se desee realizar el monitoreo.&lt;/p&gt;

&lt;p&gt;Los prerequisitos de instalación para Linux son:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt install libcurl4-gnutls-dev libjansson-dev libgtkdatabox-0.9.2-0-dev libmatio-dev
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Una vez instalados los prerequisitos, se procede a la descarga del proyecto ADI IIO Oscilloscope desde github.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone https://github.com/analogdevicesinc/iio-oscilloscope.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Una vez descargado el proyecto, este creará una carpeta llamada &lt;code class=&quot;highlighter-rouge&quot;&gt;iio-oscilloscope&lt;/code&gt;, en ella se realizarán los pasos para instalar el programa en Linux.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd iio-oscilloscope/

$ make

$ sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Una vez terminada la instalación del programa, se procede a ejecutar el programa desde la terminal de comandos.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo osc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;De igual modo se puede ejecutar el programa con el ícono de &lt;code class=&quot;highlighter-rouge&quot;&gt;ADI IIO Oscilloscope&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Debido a que no se tiene instalada la tarjeta de RF de manera local en la computadora, se debe de indicar la dirección IP de la tarjeta de evaluación donde se encuentra instalada la tarjeta de RF de Analog Devices. Para ello se hace click en &lt;code class=&quot;highlighter-rouge&quot;&gt;settings&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt;, se selecciona la opción de &lt;code class=&quot;highlighter-rouge&quot;&gt;Remote Devices (network)&lt;/code&gt; y se indica la dirección IP en la campo de &lt;code class=&quot;highlighter-rouge&quot;&gt;Hostname&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/connect_osc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finalmente se puede observar las señales capturadas en la tarjeta de RF a través de la ventana del programa de ADI IIO Oscilloscope.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/settings_osc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/spectrum_osc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name></name></author><summary type="html">El desarrollo de plataformas conectadas a la red permite que instrumentos de medición puedan ser controlados remotamente desde una computadora, de este modo, se puede compartir la instrumentación de un laboratorio sin necesidad de moverlo.</summary></entry><entry><title type="html">Configuración inicial del generador de funciones M8190A de Keysight</title><link href="http://viktorivan.github.io/keysight/m8190a/matlab/2016/08/17/configuracion-inicial-del-generador-de-funciones-m8190a-de-keysight.html" rel="alternate" type="text/html" title="Configuración inicial del generador de funciones M8190A de Keysight" /><published>2016-08-17T23:05:19+00:00</published><updated>2016-08-17T23:05:19+00:00</updated><id>http://viktorivan.github.io/keysight/m8190a/matlab/2016/08/17/configuracion-inicial-del-generador-de-funciones-m8190a-de-keysight</id><content type="html" xml:base="http://viktorivan.github.io/keysight/m8190a/matlab/2016/08/17/configuracion-inicial-del-generador-de-funciones-m8190a-de-keysight.html">&lt;p&gt;El generador de ondas arbitrarias de 12 Giga Muestras por segundo (GSa/s), es un dispositivo que genera señales de alta precisión a un gran ancho de banda por la fidelidad de su generador AWG. Es compatible con diferentes plataformas de software, tales como MATLAB y BenchLink Waveform Builder Pro.&lt;/p&gt;

&lt;p&gt;Entre las características de este dispositivo se puede mencionar: una resolución de 14 bits para 8 GSa/s y 12 bits para 12 GSa/s, generación de formas de onda arbitrarias de alta velocidad, tasa de muestreo variable de 125 MSa/s hasta 8 o 12 GSa/s, rango dinámico libre de espurios (SFDR) hasta 90dBc y un ancho de banda analógico de 5 GHz.&lt;/p&gt;

&lt;p&gt;Entre las aplicaciones en la que se puede utilizar este dispositivo, están: radar, satélite, señales multinivel, pruebas de jitter, video digital, medición de relación de potencia a ruido, OFDM, radio definido por software, entre otros.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Páginas de interés.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;www.keysight.com&quot;&gt;Keysight&lt;/a&gt; ha desarrollado diferentes herramientas para poder utilizar este dispositivo, ya sea utilizando la tarjeta PCI express o a través de la red.&lt;/p&gt;

&lt;p&gt;El dispositivo se divide en dos partes, una de ellas es el chasis donde se monta la tarjeta, el chasís &lt;a href=&quot;http://www.keysight.com/en/pd-1886662-pn-M9502A/axie-2-slot-chassis?cc=US&amp;amp;lc=eng&quot;&gt;m9502a&lt;/a&gt; tiene un &lt;a href=&quot;http://www.keysight.com/main/software.jspx?ckey=2073359&amp;amp;lc=eng&amp;amp;cc=US&amp;amp;nid=-33325.957142&amp;amp;id=2073359&quot;&gt;firmware&lt;/a&gt; que es actualizable via red, se recomienda ampliamente tener la última versión.&lt;/p&gt;

&lt;p&gt;Una vez actualizado el firmware del chasis, se procede a actualizar la tarjeta &lt;a href=&quot;http://www.keysight.com/en/pd-1969138-pn-M8190A/12-gsa-s-arbitrary-waveform-generator?nid=-33319.972199.00&amp;amp;cc=MX&amp;amp;lc=eng&quot;&gt;m8190a&lt;/a&gt; que es el generador de funciones, el &lt;a href=&quot;http://www.keysight.com/main/software.jspx?cc=US&amp;amp;lc=eng&amp;amp;id=sw385&amp;amp;pageMode=CV&quot;&gt;firmware&lt;/a&gt; es actualizable via PCI express.&lt;/p&gt;

&lt;p&gt;Finalmente, teniendo actualizados tanto el firmware del chasís como del generador de funciones, se procede a instalar el software que permitirá interactuar con el generador.&lt;/p&gt;

&lt;p&gt;Keysight desarrolló una interfaz llamada &lt;a href=&quot;http://www.keysight.com/main/software.jspx?ckey=2399836&amp;amp;lc=eng&amp;amp;cc=MY&amp;amp;nid=-11143.0.00&amp;amp;id=2399836&quot;&gt;software soft front panel&lt;/a&gt;, en ella se puede generar cualquier función, del mismo modo se desarrolló una interfaz en Matlab llamada &lt;a href=&quot;http://www.keysight.com/main/software.jspx?ckey=2759704&amp;amp;lc=eng&amp;amp;cc=US&amp;amp;nid=-33319.972199&amp;amp;id=2759704&quot;&gt;M8190A 12 GSa/s Arbitrary Waveform Generator Instrument Drivers&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Actualizar firmware del chasis M9502A.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;La actualización del firmware del chasís se puede realizar a través de la LAN, se divide en dos partes, primero hay que ejecutar el programa &lt;code class=&quot;highlighter-rouge&quot;&gt;chassisUpdater.exe&lt;/code&gt; como administrador, el cual pondrá en modo de espera el programa de actualización. Desde un navegador se ingresa a la página web del chasís y seleccionando el corazón rojo que aparece en la página se puede entrar a la sección correspondiente al estado del chasis.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/paginachasis.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/estadochasis.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/actualizacionchasis.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;En la parte inferior aparece un enlace para la actualización del firmware del chasis, el cuál abrirá una nueva página. En esta página se presiona el botón de &lt;code class=&quot;highlighter-rouge&quot;&gt;Locate Firmware Package&lt;/code&gt;, el cual buscará en la dirección IP el firmware para actualizar el chasís, la dirección IP es de la computadora donde se ejecutó en modo administador el programa &lt;code class=&quot;highlighter-rouge&quot;&gt;chassisUpdater.exe&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/paginaactualizacion.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/paginalocate.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Una vez detectado el firmware para actualizar, la página desplegará la versión actual del firmware y la versión del firmware encontrado, en caso de ser igual, recomendará no realizar ninguna actualización, en caso de ser diferente recomendará dos tipos de actualizaciones, una donde solo se actualizarán los archivos que tengan una versión diferente y otra donde actualizará todos los archivos sin importar que ya esten instalados.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/noactualizacion.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/actualizacion.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;El proceso de actualización puede tardar hasta una hora, para finalizar el proceso se tiene que cerrar la ventana de comandos de &lt;code class=&quot;highlighter-rouge&quot;&gt;chassisUpdater.exe&lt;/code&gt; y apagar el chasis con el botón azul.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Actualizar firmware del generador de funciones M8190A.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;En la computadora que esta conectada el puerto PCIe con el chasis de M9502A se debe realizar el proceso de instalación de los drivers.&lt;/p&gt;

&lt;p&gt;El instalador &lt;code class=&quot;highlighter-rouge&quot;&gt;M8190_Setup_Vx.x.x.x.exe&lt;/code&gt; es el programa que se encarga de la comunicación del generador de funciones &lt;code class=&quot;highlighter-rouge&quot;&gt;M8190A&lt;/code&gt; con la computadora a través del puerto PCIe, una vez instalado el programa, este desplegará una ventana con la información para la comunicación con el generador de funciones, es necesario ejecutar este programa cada vez que se quiera utilizar el generador de funciones.&lt;/p&gt;

&lt;p&gt;Para actualizar el firmware del generador de funciones, este tiene que estar encendido antes de prender la computadora donde esta el conector PCIe, el proceso de encendido del generador de funciones termina cuando el led de &lt;code class=&quot;highlighter-rouge&quot;&gt;FAIL&lt;/code&gt; se apaga y se enciende el de &lt;code class=&quot;highlighter-rouge&quot;&gt;ACCESS&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;El instalador del &lt;code class=&quot;highlighter-rouge&quot;&gt;M8190A&lt;/code&gt; buscará la conexión con el generador de funciones e instalará los drivers adecuados, tanto en la computadora como en el generador de funciones &lt;code class=&quot;highlighter-rouge&quot;&gt;M8190A&lt;/code&gt;. Una vez realizado este proceso se tiene que reiniciar el generador de funciones, para ello hay que apagar primero la computadora y despues el generador de funciones.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/firmwarem8190a.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Uso del generador de funciones M8190A.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Para utilizar el generador de funciones existe un orden de encendido de los equipos, primero se debe encender el generador de funciones &lt;code class=&quot;highlighter-rouge&quot;&gt;M8190A&lt;/code&gt; hasta que el led de &lt;code class=&quot;highlighter-rouge&quot;&gt;ACCESS&lt;/code&gt; se encienda, una vez hecho esto se ejecuta el programa &lt;code class=&quot;highlighter-rouge&quot;&gt;Keysight M8190A&lt;/code&gt;, el cual se encarga de habilitar la comunicación entre el generador de funciones y la computadora a través del puerto PCIe, cuando aparezca la ventana con los datos de comunicación del generador de funciones se puede ejecutar el programa que controlará al generador de funciones.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/keysightm8190a.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/firmwarem8190a.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;desde Soft Front Panel M8190.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Este programa es útil para comunicarse con el generador de funciones y probar funciones de una manera sencilla, al ejecutar el programa aparecen varias pestañas donde se puede escoger entre los diferentes tipos de funciones o señales que se deseen generar, asi también indicar los puertos de salida de la señal. Una vez generada la señal a generar es necesario poner &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt; en la pestaña de &lt;code class=&quot;highlighter-rouge&quot;&gt;status/control&lt;/code&gt; para observar la señal en algún equipo de medición como osciloscopio o analizador de espectro.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/softfrontpanel.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/softfrontpanelsenal.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;desde iqtools de Matlab.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Otra alternativa es utilizar la herramienta de &lt;code class=&quot;highlighter-rouge&quot;&gt;Matlab&lt;/code&gt; llamada &lt;code class=&quot;highlighter-rouge&quot;&gt;iqtools&lt;/code&gt;, los archivos de &lt;code class=&quot;highlighter-rouge&quot;&gt;iqtools&lt;/code&gt; se instalan en la carpeta de &lt;code class=&quot;highlighter-rouge&quot;&gt;Keysight&lt;/code&gt; en la sección correspondiente a los ejemplos. Esta interfaz es útil para generar señales de forma rapida a través de &lt;code class=&quot;highlighter-rouge&quot;&gt;Matlab&lt;/code&gt;, asi mismo permite cargar datos de señales personalizadas en la interfaz de &lt;code class=&quot;highlighter-rouge&quot;&gt;iqtools&lt;/code&gt;, el archivo &lt;code class=&quot;highlighter-rouge&quot;&gt;mat&lt;/code&gt; debe indicar las muestras de la señal y el periodo de muestreo que es el inverso de la tasa de muestreo.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/archivosiqtools.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/iqtools.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/instrumentoiqtools.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/senaliqtools.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name>Iván Rodríguez</name></author><summary type="html">El generador de ondas arbitrarias de 12 Giga Muestras por segundo (GSa/s), es un dispositivo que genera señales de alta precisión a un gran ancho de banda por la fidelidad de su generador AWG. Es compatible con diferentes plataformas de software, tales como MATLAB y BenchLink Waveform Builder Pro.</summary></entry><entry><title type="html">Vocoders para banda angosta en GNU Radio</title><link href="http://viktorivan.github.io/gnuradio/codec2/cvsd/sdr/2016/04/09/vocoders-para-banda-angosta-en-gnu-radio.html" rel="alternate" type="text/html" title="Vocoders para banda angosta en GNU Radio" /><published>2016-04-09T12:35:02+00:00</published><updated>2016-04-09T12:35:02+00:00</updated><id>http://viktorivan.github.io/gnuradio/codec2/cvsd/sdr/2016/04/09/vocoders-para-banda-angosta-en-gnu-radio</id><content type="html" xml:base="http://viktorivan.github.io/gnuradio/codec2/cvsd/sdr/2016/04/09/vocoders-para-banda-angosta-en-gnu-radio.html">&lt;p&gt;Un vocoder analiza el habla midiendo los cambios en el tiempo de sus características espectrales. El resultado es una serie de señales que representan a las frecuencias que se modificaron en un tiempo particular mientras el usuario hablaba. En otras palabras, la señal se divide en un número de bandas de frecuencias y el nivel de la señal presente en cada banda de frecuencia es la representación instantánea de su energía espectral. De este modo, el vocoder reduce sustancialmente la cantidad de información requerida para almacenar una charla.&lt;/p&gt;

&lt;p&gt;En el codificador, la voz se envía a un banco de filtros de varias bandas, la señal filtrada de cada una de esas bandas se pasa a través de un seguidor de envolvente y las señales de control (amplitudes de la señal) de esta etapa son enviadas al decodificador. En el receptor, la etapa de decodificación utiliza estas señales de control para configurar correctamente los filtros correspondientes para resintetizar la voz. Estas señales de control ocupan un menor ancho de banda que la voz original, por lo que permite la multicanalización en los enlaces y el uso de banda angosta para su transmisión.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;CODEC2.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Codec2 es un codec para conversaciones de audio de baja tasa de bit libre de patente y de fuente abierta. Codec2 comprime las conversaciones utilizando codificación senoidal, el cuál es un método especializado para conversaciones humanas. Fue diseñado para ser utilizado en radio amateur y otras aplicaciones de voz de alta compresión.&lt;/p&gt;

&lt;p&gt;Los modos de codec2 son: 3200, 2400, 1600, 1400, 1300, 1200 y 700 bps. Su desempeño es mejor que varios codecs de tasa baja. Por ejemplo, utiliza la mitad del ancho de banda de el método de Excitación Multi-Banda Avanzada para codificar una conversación con una calidad similar. La entrada del codec es un audio muestreado con PCM de 16 bits y la salida son paquetes de bytes. El audio recuperado de estos bytes es de 8 KHz.&lt;/p&gt;

&lt;p&gt;Por ejemplo, para el modo 3200, tiene 20 ms de audio convertidos en 64 Bits. Estos 64 Bits salen cada 20 ms, para una tasa de transmisión mínima de 3200 bps. Estos 64 Bits son enviados como 8 bytes al canal de datos.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Modulación delta de pendiente variable contínua (CVSD).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;CVSD es un método de codificación de voz que utiliza modulación delta con escalones de tamaño variable. CVSD codifica 1 bit por muestra, por lo que un audio de 16 KHz es codificado a 16 Kbps. El codificador mantiene una muestra de referencia y un tamaño de escalón. Cada muestra de entrada se compara con la muestra de referencia. Si la muestra de entrada es grande, el codificador envía un 1 bit y le suma el tamaño del escalón de la muestra de referencia. Si la muestra de entrada es pequeña, el codificador envía un 0 bit y le resta el tamaño del escalón de la muestra de referencia. Además, el codificador guarda los N bits previos de la salida (Los valores comunes de N son 3 y 4) para determinar los ajustes del tamaño del escalón.&lt;/p&gt;

&lt;p&gt;El proceso de la decodificación se realiza a partir de la muestra de referencia, sumando o restando el tamaño del escalón de acuerdo al flujo de bits. La secuencia de muestras de referencia ajustadas son la forma de onda reconstruida, y el tamaño del escalón se ajusta de acuerdo a los 1 y 0 lógicos tal como en el codificador.&lt;/p&gt;

&lt;p&gt;CVSD tiene un compromiso entre sencillez, baja tasa de bit y calidad. Las tasas de bit comunes son de 9.6 a 128 Kbps&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Simulación con GNU Radio.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Para la implementación de los vocoders en GNU Radio se requiere de un archivo de audio de una conversación a una tasa de muestreo de 8 KHz, los archivos de música no son recomendados ya que los vocoders están optimizados para comprimir voz. El tipo de dato de este archivo es interpretado como float, para hacer el cambio a short se tiene que multiplicar por 32767 y en el receptor dividir por la misma cantidad para mantener la igualdad de los datos durante la simulación.&lt;/p&gt;

&lt;p&gt;Como requisito, CODEC2 pide que las muestras no tengan algún tipo de empaquetamiento, por lo que se agrega el bloque de Packed to Unpacked con un tamaño de 16 bits. Finalmente en el receptor se agrega un bloque de remuestreo para adaptar la señal reconstruida de 8 KHz a la tasa de muestreo de la tarjeta de audio, en este caso de 48 KHz.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/codec2_test_grc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Los datos de salida del codec son una secuencia bits de 1 y 0 logicos que pueden ser enviados al modulador digital para su transmisión posterior. De igual modo, es posible agregar una visualización de los datos a la salida del decodificador, para hacer una comparación de los datos codificados y decodificados.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/codec2_sim.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;La implementación del codec CVSD es similar a la simulación de CODEC2, se puede observar que la salida del codec CVSD es diferente a la salida de CODEC2, no entrega vectorizado los datos, sino en un flujo de datos Char que pueden ser enviados directamente al modulador digital.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/cvsd_test_grc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Los datos de salida del codec no son una secuencia de bits, sino muestras con valores entre -100 y 100.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/cvsd_sim.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Conclusión.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El uso de vocoders es muy utilizado en los sistemas de comunicación actuales, ya que permiten tener varios enlaces de voz compartiendo el mismo canal, o en su defecto, realizar una conversación en canales de banda angosta, todo esto usando enlaces de comunicación digital. GNU Radio permite la implementación de un sistema de comunicación de voz con vocoders que pueden ser combinados con otros esquemas para tener un sistema completo funcional.&lt;/p&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name></name></author><summary type="html">Un vocoder analiza el habla midiendo los cambios en el tiempo de sus características espectrales. El resultado es una serie de señales que representan a las frecuencias que se modificaron en un tiempo particular mientras el usuario hablaba. En otras palabras, la señal se divide en un número de bandas de frecuencias y el nivel de la señal presente en cada banda de frecuencia es la representación instantánea de su energía espectral. De este modo, el vocoder reduce sustancialmente la cantidad de información requerida para almacenar una charla.</summary></entry><entry><title type="html">DPSK y GFSK en GNU Radio</title><link href="http://viktorivan.github.io/gfsk/dpsk/sdr/gnuradio/2016/04/09/dpsk-y-gfsk-en-gnu-radio.html" rel="alternate" type="text/html" title="DPSK y GFSK en GNU Radio" /><published>2016-04-09T12:34:39+00:00</published><updated>2016-04-09T12:34:39+00:00</updated><id>http://viktorivan.github.io/gfsk/dpsk/sdr/gnuradio/2016/04/09/dpsk-y-gfsk-en-gnu-radio</id><content type="html" xml:base="http://viktorivan.github.io/gfsk/dpsk/sdr/gnuradio/2016/04/09/dpsk-y-gfsk-en-gnu-radio.html">&lt;p&gt;La modulación digital consiste en una técnica donde la portadora es modulada para el envío de datos digitales (donde los datos se conforman generalmente por una cadena de unos y ceros) en vez de formas de ondas analógicas. Estos datos pueden representar información analógica (tal como la voz, audio, video), por lo que son el resultado de pasar previamente por una etapa de conversión de analógico a digital (ADC) para poder ser modulados digitalmente, esto es, tienen que representarse por medio de un valor definido dentro de un rango previamente especificado.&lt;/p&gt;

&lt;p&gt;Existen diversos tipos de moduladores digitales:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;por cambio de fase (PSK).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;por cambio de frecuencia (FSK).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;por cambio de amplitud (ASK).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;modulación de amplitud en cuadratura (QAM).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Los cambios en alguna característica de la portadora están definidos previamente en una constelación, que es una tabla donde se indica que cambios se harán en la portadora si se presenta una combinación de bits en específico. Esto es, si en la entrada se recibe la cadena &lt;code class=&quot;highlighter-rouge&quot;&gt;010&lt;/code&gt;, el modulador revisa la constelación donde se le indica que debe hacer un desfasamiento en la portadora de 135 grados. Cuando el receptor observe este cambio de fase, lo interpretará como la cadena de bits &lt;code class=&quot;highlighter-rouge&quot;&gt;010&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Modulación por desplazamiento diferencial de fase (DPSK).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;DPSK es una técnica de modulación que consiste en variar la fase actual de la portadora de acuerdo a los bits de entrada. La ventaja de este tipo de transmisión, en comparación con PSK, es que no requiere de una señal coherente para su sincronización, debido a los cambios de fase que realiza sobre la portadora, de este modo se pueden ignorar los cambios de fase que pueden presentarse en la señal por los efectos del canal inalámbricos.&lt;/p&gt;

&lt;p&gt;En el caso de DBPSK (donde la tasa de transmisión es un bit por símbolo), cuando se desea transmitir un &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; se le suma 180° a la fase actual de la portadora, en caso de que se desea transmitir un &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; se le suma 0° a la fase actual, por lo que no existe algún cambio de fase en la portadora. En cambio, para la modulación utilizando DQPSK (dos bits por símbolo), los cambios de fase son 0°, 90°, 180° y -90° que corresponden a los datos &lt;code class=&quot;highlighter-rouge&quot;&gt;00&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;01&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;11&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt; respectivamente.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Modulación por desplazamiento de frecuencia gausiana (GFSK)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;GFSK es una técnica que realiza transiciones suaves entre cada símbolo digital, evitando de este modo el cambio abrupto de frecuencia durante la transmisión, que ha diferencia de FSK, esta no realiza transiciones de frecuencia de un modo suave, llegando a presentarse algunas transiciones de frecuencia de 180°. GFSK consiste en un banco de filtros Gausianos donde los pulsos digitales (pulsos cuadrados que representan los unos y ceros) son suavizados antes de entrar a la etapa de modulación, esto es, los pulsos cuadrados tienen una forma de onda mas parecido a una onda senoidal, pero sin perder su periodo. Este filtro tiene la ventaja de reducir la potencia de la banda lateral, la interferencia con canales adyacentes pero el costo es el incremento de la interferencia intersímbolo.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Simulación en GNU Radio&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;GNU Radio incluye diferentes tipos de moduladores digitales dentro de sus bloques de procesamiento, permitiendo de este modo la fácil implementación de un modulador digital. En las figuras se puede observar un diagrama a bloques de un lazo cerrado utilizando modulación digital DPSK y GFSK respectivamente, en la cuál la señal a transmitir es una forma de onda senoidal que puede ser modificada en la frecuencia en tiempo real y así observar en el receptor que los cambios hechos en el transmisor son reflejados correctamente.&lt;/p&gt;

&lt;p&gt;En los diagramas a bloques se puede observar el bloque Packet Encoder, que consiste en agrupar los bits de acuerdo a la cantidad de símbolos disponibles en el modulador digital, en el caso de DQPSK los bits son agrupados de dos en dos, para DBPSK y GFSK son de uno en uno.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/gfsk.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/dpsk.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Estos ejemplos se incluyen dentro del proyecto de GNU Radio.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Conclusión.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El uso de estos esquemas de modulación digital permiten una implementación rápida y sencilla con las tarjetas USRP, ya que son lo suficientemente robustos que no necesitan agregar etapas adicionales al receptor. GNU Radio incluye dentro del proyecto varios ejemplos de sus diferentes sistemas funcionando, de este modo, facilita el entendimiento de los sistemas de comunicación con dispositivos de hardware.&lt;/p&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name></name></author><summary type="html">La modulación digital consiste en una técnica donde la portadora es modulada para el envío de datos digitales (donde los datos se conforman generalmente por una cadena de unos y ceros) en vez de formas de ondas analógicas. Estos datos pueden representar información analógica (tal como la voz, audio, video), por lo que son el resultado de pasar previamente por una etapa de conversión de analógico a digital (ADC) para poder ser modulados digitalmente, esto es, tienen que representarse por medio de un valor definido dentro de un rango previamente especificado.</summary></entry><entry><title type="html">Cifrado en GNU Radio con gr-NaCl</title><link href="http://viktorivan.github.io/cifrado/gnuradio/out-of-tree/2016/04/08/cifrado-en-gnu-radio-con-gr-nacl.html" rel="alternate" type="text/html" title="Cifrado en GNU Radio con gr-NaCl" /><published>2016-04-08T01:04:29+00:00</published><updated>2016-04-08T01:04:29+00:00</updated><id>http://viktorivan.github.io/cifrado/gnuradio/out-of-tree/2016/04/08/cifrado-en-gnu-radio-con-gr-nacl</id><content type="html" xml:base="http://viktorivan.github.io/cifrado/gnuradio/out-of-tree/2016/04/08/cifrado-en-gnu-radio-con-gr-nacl.html">&lt;p&gt;Una forma sencilla de describir lo que es cifrado es: Aquello que está escrito con letras, símbolos o números que solo pueden comprenderse si se dispone de la clave necesaria para descifrarlos.&lt;/p&gt;

&lt;p&gt;En criptografía, el cifrado es un procedimiento que utiliza un algoritmo de cifrado con una clave para transformar un mensaje que se desea enviar, sin atender a su estructura lingüística o significado, de tal forma que sea incomprensible o, al menos, difícil de comprender a toda persona que no tenga la clave de descifrado del algoritmo.&lt;/p&gt;

&lt;p&gt;A veces el texto cifrado se escribe en bloques de igual longitud. A estos bloques se les denomina grupos. Estos grupos proporcionaban una forma de verificación adicional, ya que el texto cifrado obtenido debía tener un número entero de grupos. Si al cifrar el texto plano no se tiene ese número entero de grupos, entonces se suele rellenar al final con ceros o con caracteres sin sentido.&lt;/p&gt;

&lt;p&gt;En el caso de cifrado de conversaciones de voz o aplicaciones de tiempo real, el cifrado en bloques no es adecuado porque los flujos de datos que se pueden llegar a producir pueden ser fragmentos pequeños. Las muestras de datos pueden ser tan pequeñas como 8 bits, en caso de que los bloques sean de 64 bits, es necesario rellenar con ceros antes de cifrar y transmitirlos lo que puede traducirse en un uso ineficiente de la capacidad del sistema.&lt;/p&gt;

&lt;p&gt;Los cifradores de flujo son algoritmos de cifrado que pueden realizar el cifrado incrementalmente, convirtiendo los datos en claro en datos cifrado bit a bit. Esto se logra construyendo un generador de flujo de clave. Un flujo de clave es una secuencia de bits de tamaño arbitrario que puede emplearse para oscurecer los contenidos de un flujo de datos combinando el flujo de clave con el flujo de datos mediante la función XOR. Si el flujo de clave es seguro, el flujo de datos cifrados también lo será.&lt;/p&gt;

&lt;p&gt;Se puede construir un generador de flujo de clave iterando una función matemática sobre un rango de valores de entrada para producir un flujo continuo de valores de salida. Los valores de salida se concatenan entonces para construir bloques de datos en claro, y los bloques se cifran empleando una clave compartida por el emisor y el receptor.&lt;/p&gt;

&lt;p&gt;Para conservar la calidad de servicio del flujo de datos, los bloques del flujo de clave deberían producirse con un poco de antelación sobre el momento en que vayan a ser empleados, además el proceso que los produce no deberá exigir demasiado esfuerzo de procesamiento como para retrasar el flujo de datos.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cifrado de flujo Salsa20&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://cr.yp.to/snuffle.html&quot;&gt;Salsa20&lt;/a&gt; es un cifrador de flujo propuesto a eSTREAM por Daniel J. Bernstein. Utiliza una función pseudoaleatoria en operaciones ARX (add-rotate-xor), que son operaciones de sumas de 32 bits, suma bit a bit (XOR) y rotación. Salsa20 proyecta una clave de 256 bits, un nonce de 64 bits y un flujo de 64 bits a una salida de 512 bits. Esto provee a Salsa20 una ventaja inusual, la cuál es que el usuario pueda buscar eficientemente cualquier posición de la salida en tiempo constante. Tiene una velocidad de alrededor de 4 a 14 ciclos por byte en software en procesadores x86 modernos y un desempeño en hardware razonable. No está patentado, y Bernstein ha escrito varias implementaciones de dominio público, optimizadas para arquitecturas comunes.&lt;/p&gt;

&lt;p&gt;Un nonce es una frase o número arbitrario utilizado sólo una vez en una comunicación cifrada, tal como lo indica su traducción: mientras tanto. Un nonce puede ser una palabra aleatoria o pseudoaleatoria, incluso puede ser utilizado para verificar fecha y hora, ya que este dato puede ser parte del nonce. Para asegurar que nonce sea utilizado sólo una vez, esté debe ser variante en el tiempo (el incluir la hora podría ser suficiente) o pueden generarse una gran cantidad de bits aleatorios que aseguren que la probabilidad de que se repita sea muy pequeña. El uso de nonce permite que viejos mensajes no puedan ser utilizados durante un ataque.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;NaCl: Librería de cifrado y red.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://nacl.cr.yp.to/&quot;&gt;NaCl&lt;/a&gt; (se pronuncia “sal”, por el cloruro de sodio) es una librería de software de alta velocidad y fácil de usar orientada a redes de comunicación, cifrado, descrifrado, firmas, entre otras cosas. El objetivo de NaCl es ofrecer todas las operaciones core que se necesitan para hacer herramientas de cifrado del más alto nivel.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Librería de cifrado Sodium.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://libsodium.org&quot;&gt;Sodium&lt;/a&gt; es una librería de software moderna, fácil de usar para cifrado, descifrado, firmas y hash de contraseñas. Es portátil, soporta compilación cruzada, instalable, es un paquete de bifurcación de NaCl con una API compatible y con una API extendida que mejora su uso.&lt;/p&gt;

&lt;p&gt;Sodium soporta una variedad de compiladores y sistemas operativos, incluyendo Windows, iOS y Android.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;gr-nacl: Módulo de GNU Radio para el cifrado de datos utilizando la librería NaCl.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El módulo &lt;a href=&quot;http://www.cgran.org/pages/gr-nacl.html&quot;&gt;gr-nacl&lt;/a&gt; para GNU Radio utiliza la librería de cifrado NaCl desarrollada con la bifurcación de la librería Sodium. Entre los bloques incluidos está el cifrado de llave pública y llave secreta. La implementación se basa en el cifrado de mensajes, el cual usa el sistema de mensajes de GNU Radio, adicionalmente, se implementó un sistema de cifrado por medio de flujos etiquetados (tagged streams).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instalación.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Desde una terminal, se procede a instalar la librería de Sodium,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/jedisct1/libsodium.git
cd libsodium/
./autogen.sh
./configure
make
sudo make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Una vez instalado, se instala el módulo de gr-nacl para GNU Radio.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/stwunsch/gr-nacl.git
cd gr-nacl/
mkdir build
cd build
cmake ../
make
ctest
sudo make install
sudo ldconfig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Instalación utilizando PyBombs&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;De igual modo, se puede instalar el proyecto de gr-NaCl utilizando los comandos de PyBombs.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo pybombs -p myprefix install gr-nacl
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Funcionamiento&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Una vez instalado gr-nacl, se procede a hacer una prueba de cifrado. En el ejemplo incluido en el proyecto se puede observar el archivo de entrada, que es un archivo de texto con la palabra: “This is a test text. Hello world!”. Una vez ejecutado el grc, se pueden observar tres archivos de salida, uno donde se muestra la palabra de entrada, el segundo donde se observa el archivo cifrado y por último el archivo descifrado.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/stream_encryption.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Conclusión.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Aunque el ejemplo mostrado es sencillo, es una base para implementarlo en sistemas mas complejos, como el cifrado de voz o mensajes de chat para su eventual transmisión con alguna tarjeta USRP.&lt;/p&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name></name></author><summary type="html">Una forma sencilla de describir lo que es cifrado es: Aquello que está escrito con letras, símbolos o números que solo pueden comprenderse si se dispone de la clave necesaria para descifrarlos.</summary></entry><entry><title type="html">Instalación GNU Radio con PyBombs versión 2</title><link href="http://viktorivan.github.io/gnuradio/pybombs/instalacion/2016/03/30/instalacion-gnu-radio-con-pybombs-version-2.html" rel="alternate" type="text/html" title="Instalación GNU Radio con PyBombs versión 2" /><published>2016-03-30T02:24:26+00:00</published><updated>2016-03-30T02:24:26+00:00</updated><id>http://viktorivan.github.io/gnuradio/pybombs/instalacion/2016/03/30/instalacion-gnu-radio-con-pybombs-version-2</id><content type="html" xml:base="http://viktorivan.github.io/gnuradio/pybombs/instalacion/2016/03/30/instalacion-gnu-radio-con-pybombs-version-2.html">&lt;p&gt;&lt;a href=&quot;http://gnuradio.org&quot;&gt;GNU Radio&lt;/a&gt; es un proyecto de software libre orientado a radio definido por software, basado en Python; existen diversos medios para instalar el conjunto de herramientas que comprenden a GNU Radio, desde los repositorios utilizando &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; hasta la instalación desde el código fuente del proyecto en la terminal, con ayuda de un script o con un gestor de paquetes. La ventaja de instalar GNU Radio desde el código fuente con respecto a los repositorios es la versión de instalación, ya que los repositorios pueden tardar en actualizarse con respecto a los avances del proyecto.&lt;/p&gt;

&lt;p&gt;Anteriormente, GNU Radio desarrolló una primera versión de &lt;a href=&quot;https://github.com/gnuradio/pybombs/&quot;&gt;PyBombs&lt;/a&gt; que permitía la instalación del proyecto de una manera sencilla e inclusive intuitiva. Debido a la popularidad de PyBombs para la instalación de proyectos OOT de GNU Radio, se realizó una actualización que permite la fácil distribución e instalación de proyectos pero ahora es incluido desde el gestor &lt;a href=&quot;https://pip.pypa.io&quot;&gt;pip&lt;/a&gt; de Python.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instalación.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Primeramente es necesario instalar el gestor pip de Python, desde una terminal.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install python-pip python-dev build-essential git
$ sudo pip install --upgrade pip
$ sudo pip install --upgrade virtualenv
$ sudo pip install setuptools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Una vez instalado el gestor de aplicaciones de Python, se procede a la instalación de PyBombs.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo pip install -Iv PyBOMBS==2.1.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Teniendo una vez instalado el proyecto de PyBombs, se descargan las recetas donde están indicadas las ubicaciones de los proyectos para su descarga.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ pybombs recipes add gr-recipes git+https://github.com/gnuradio/gr-recipes.git
$ pybombs recipes add gr-etcetera git+https://github.com/gnuradio/gr-etcetera.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Para que GNU Radio pueda ser ejecutado desde cualquier ubicación se tiene que indicar donde se instalará el proyecto.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo pybombs prefix init /usr/local -a myprefix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Una vez inicializado el prefijo, se procede a la instalación de GNU Radio desde PyBombs.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo pybombs -p myprefix install gnuradio gr-osmosdr
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Para ejecutar la interfaz gráfica de GNU Radio, sólo se ejecuta el comando.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gnuradio-companion
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Íconos de GNU Radio&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Para la instalación de los íconos, desde una terminal se ejecuta el comando:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo /usr/local/libexec/gnuradio/grc_setup_freedesktop install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;De este modo, de manera automática se agregarán los íconos a los diferentes menús de la distribución de Linux.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Imágenes del firmware de USRP&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Para poder utilizar las tarjetas USRP en el entorno de GNU Radio es necesario descargar las imágenes del firmware, esto se realiza con el siguiente comando:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo /usr/local/lib/uhd/utils/uhd_images_downloader.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Otros comandos de PyBombs para GNU Radio&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;La aplicación de PyBombs tiene diferentes parámetros que permiten agregar, actualizar o remover diferentes elementos del entorno de GNU Radio.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;usage: pybombs [-h] [--version] [-p PREFIX] [--prefix-conf PREFIX_CONF]
               [--config CONFIG] [--config-file CONFIG_FILE] [-r RECIPES] [-q]
               [-v] [-y]
               &amp;lt;command&amp;gt; ...
pybombs: error: argument &amp;lt;command&amp;gt;: invalid choice: 'upgrade' (choose from 'config', 'lint', 'remove', 'update', 'install', 'rebuild', 'refetch', 'fetch', 'help', 'show', 'digraph', 'inv', 'deploy', 'recipes', 'prefix')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Para actualizar el entorno o uno de los elementos de GNU Radio se utiliza el comando:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo pybombs -p myprefix update gnuradio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Si se desea conocer la lista de las aplicaciones instaladas,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo pybombs -p myprefix update inv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Actualización de GNU Radio&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El entorno de GNU Radio se puede actualizar con el comando de update de PyBombs&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo pybombs -p myprefix update gnuradio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;En caso de que se presenten errores durante la actualización, puede que sea necesario mandar descargar nuevamente el código fuente de GNU Radio&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo pybombs -p myprefix rebuild gnuradio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;En caso de que todavía se presenten errores, es necesario reinicializar PyBombs, esto se hace eliminando diversas carpetas ocultas.&lt;/p&gt;

&lt;p&gt;Una de ellas se ubica en la carpeta de &lt;code class=&quot;highlighter-rouge&quot;&gt;Home&lt;/code&gt;, se llama &lt;code class=&quot;highlighter-rouge&quot;&gt;.pybombs&lt;/code&gt;, que es donde se descargaron los archivos de &lt;code class=&quot;highlighter-rouge&quot;&gt;recipes&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;La segunda de ellas se ubica en &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local&lt;/code&gt;, se llama &lt;code class=&quot;highlighter-rouge&quot;&gt;.pybombs&lt;/code&gt;, y en ella se encuentra el archivo que indica el prefijo de instalación de GNU Radio.&lt;/p&gt;

&lt;p&gt;Finalmente se eliminan las carpetas relacionadas a las descargas del código fuente del entorno de GNU Radio, ubicado en ´/usr/local/src´.&lt;/p&gt;

&lt;p&gt;Una vez eliminado todos estos archivos, se procede a descargar los archivos &lt;code class=&quot;highlighter-rouge&quot;&gt;recipes&lt;/code&gt; e indicar el prefijo. De este modo, PyBombs instalará el entorno de GNU Radio sin tomar en consideración las versiones previas descargadas.&lt;/p&gt;

&lt;p&gt;En caso de que el problema de la actualización persista, será necesario eliminar todos los archivos de GNU Radio ubicados en &lt;code class=&quot;highlighter-rouge&quot;&gt;usr/local/&lt;/code&gt;, realizando de este modo una desinstalación manual del entorno.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Permisos de UHD para GNU Radio&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;En caso de que al querer ejecutar un archivo de GRC que incluya el bloque de UHD y salga el error siguiente:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UHD Error:
    USB open failed: insufficient permissions.
    See the application notes for your device.

    RuntimeError: LookupError: KeyError: No devices found for -----&amp;gt;
Empty Device Address
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Se debe a que no se tienen los permisos para utilizar el puerto USB, una solución rápida es ejecutar GRC con permisos de root.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo gnuradio-companion
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Para evitar ejecutar GRC como superusuario, es necesario actualizar las reglas, en primera instancia hay que localizar el archivo de las reglas de UDH, copiar el archivo en la ubicación de las reglas y finalmente volver a cargar las reglas del sistema.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo find / -name uhd-usrp.rules
/usr/local/src/uhd/host/utils/uhd-usrp.rules
/usr/local/lib/uhd/utils/uhd-usrp.rules

$ sudo cp /usr/local/src/uhd/host/utils/uhd-usrp.rules /etc/udev/rules.d/

$ sudo udevadm control --reload-rules
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Conclusión.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El proyecto de PyBombs de GNU Radio ha mostrado un cambio que puede interpretarse como positivo, ya que permite agregar proyectos OOT de una manera sencilla e incluso modificar las recetas para proyectos personales y facilitar su distribución e instalación.&lt;/p&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name></name></author><summary type="html">GNU Radio es un proyecto de software libre orientado a radio definido por software, basado en Python; existen diversos medios para instalar el conjunto de herramientas que comprenden a GNU Radio, desde los repositorios utilizando apt-get hasta la instalación desde el código fuente del proyecto en la terminal, con ayuda de un script o con un gestor de paquetes. La ventaja de instalar GNU Radio desde el código fuente con respecto a los repositorios es la versión de instalación, ya que los repositorios pueden tardar en actualizarse con respecto a los avances del proyecto.</summary></entry><entry><title type="html">Instalación de GNU Radio embedded en tarjetas ZedBoard</title><link href="http://viktorivan.github.io/gnuradio/embedded/zedboard/2015/11/28/instalacion-de-gnu-radio-embedded-en-tarjetas-zedboard.html" rel="alternate" type="text/html" title="Instalación de GNU Radio embedded en tarjetas ZedBoard" /><published>2015-11-28T19:21:27+00:00</published><updated>2015-11-28T19:21:27+00:00</updated><id>http://viktorivan.github.io/gnuradio/embedded/zedboard/2015/11/28/instalacion-de-gnu-radio-embedded-en-tarjetas-zedboard</id><content type="html" xml:base="http://viktorivan.github.io/gnuradio/embedded/zedboard/2015/11/28/instalacion-de-gnu-radio-embedded-en-tarjetas-zedboard.html">&lt;p&gt;El uso de sistemas embebidos se ha popularizado y beneficiado por las nuevas tecnologías, ya que ahora permiten implementar sistemas que no solo controlen de un modo básico y simple un dispositivo, sino que pueden formar parte de un ecosistema que incluya conectividad a Internet y por lo tanto monitoreo y control remoto. Adicionalmente, tendencias como el radio definido por software (SDR) han integrado a sus desarrollos la implementación en sistemas embebidos lo que permite el desarrollo de un sistema de comunicación completo en un ambiente embebido, disminuyendo costos y proporcionando portatibilidad.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instalación.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A diferencia de los sistemas operativos convencionales, el instalar un sistema embebido puede verse limitado por la arquitectura de hardware del sistema embebido, por lo que su instalación puede llegar a ocupar varias horas o incluso interrumpirse por la falta de recursos. Una alternativa es la compilación cruzada, donde en una computadora con mejores prestaciones que el hardware de un sistema embebido compila todo el software necesario para el desarrollo del sistema operativo embebido, pero con las librerías que le corresponden al sistema embebido, esto es, se realizará la compilación de una arquitectura de un sistema embebido en una arquitectura de hardware diferente.&lt;/p&gt;

&lt;p&gt;Existen varios proyectos para el desarrollo de sistemas embebidos, tales como &lt;a href=&quot;http://www.openembedded.org&quot;&gt;openembbeded&lt;/a&gt;  o &lt;a href=&quot;https://www.yoctoproject.org&quot;&gt;yocto project&lt;/a&gt;. &lt;a href=&quot;http://gnuradio.org&quot;&gt;GNU Radio&lt;/a&gt; por su parte, proporciona un procedimiento para generar un sistema operativo embebido con &lt;a href=&quot;https://gnuradio.org/redmine/projects/gnuradio/wiki/Embedded&quot;&gt;GNU Radio&lt;/a&gt;integrado al momento de realizar la compilación cruzada.&lt;/p&gt;

&lt;p&gt;Para el correcto funcionamientod de OpenEmbedded, se requiere de los siguientes prerequisitos.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat libsdl1.2-dev xterm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Una vez cumplidos los prerequisitos se procede a la descarga del proyecto repo.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ curl http://commondatastorage.googleapis.com/git-repo-downloads/repo &amp;gt; repo
$ chmod a+x repo
$ sudo mv repo /usr/local/bin/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Se crea el directorio de trabajo del proyecto.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir oe-repo
$ cd oe-repo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Se indica que el sistema embebido incluye GNU Radio.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ repo init -u git://github.com/balister/oe-gnuradio-manifest.git -b fido
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Se actualiza el proyecto e indica el modelo de la plataforma a utilizar.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ repo sync
$ TEMPLATECONF=`pwd`/meta-sdr/conf source ./oe-core/oe-init-build-env ./build ./bitbake
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Al momento de ejecutar el proyecto puede generar diversos tipos de errores, tal como este, donde no se indicó la plataforma&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;You had no conf/local.conf file. This configuration file has therefore been
created for you with some default values. You may wish to edit it to use a
different MACHINE (target hardware) or enable parallel build options to take
advantage of multiple cores for example. See the file for more information as
common configuration options are commented.

You had no conf/bblayers.conf file. The configuration file has been created for
you with some default values. To add additional metadata layers into your
configuration please add entries to this file.

The Yocto Project has extensive documentation about OE including a reference
manual which can be found at:
    http://yoctoproject.org/documentation

For more information about OpenEmbedded see their website:
    http://www.openembedded.org/


### Shell environment set up for builds. ###

You can now run 'bitbake &amp;lt;target&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Se indica la plataforma de hardware del sistema embebido, en este caso es una tarjeta &lt;code class=&quot;highlighter-rouge&quot;&gt;Zedboard&lt;/code&gt; y con el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;bitbake&lt;/code&gt; se inicia la creación del sistema embebido, debido a la descarga de software esta operación llega a consumir hasta 50 GB de disco duro, igualmente puede tardar mucho tiempo por la velocidad del enlace de Internet.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export MACHINE=&quot;zedboard-zynq7&quot;
$ bitbake gnuradio-dev-image
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;En caso de que falte algún paquete, el proyecto indicará la falta del mismo.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NOTE: Your conf/bblayers.conf has been automatically updated.
ERROR:  OE-core's config sanity checker detected a potential misconfiguration.
    Either fix the cause of this error or at your own risk disable the checker (see sanity.conf).
    Following is the list of potential problems / advisories:

    Please install the following missing utilities: chrpath
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Este problema se soluciona a través de &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install chrpath
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Otro de los errores que se pueden presentar es la falta de recetas al momento de generar el sistema embebido.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Parsing recipes: 100% |#######################################| Time: 00:00:30
Parsing of 1939 .bb files complete (0 cached, 1939 parsed). 2455 targets, 247 skipped, 0 masked, 0 errors.
ERROR: No recipes available for:
  /home/cidte/oe-repo/oe-core/../meta-fsl-arm/openembedded-layer/recipes-support/opencv/opencv_3.0.bbappend
  /home/cidte/oe-repo/oe-core/../meta-fsl-arm-extra/recipes-kernel/linux/linux-timesys_3.0.15.bbappend

Summary: There was 1 ERROR message shown, returning a non-zero exit code.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;En caso de que alguna receta no este disponible para su descarga será necesario eliminarla de la lista de recetas.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ gedit conf/bblayers.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dentro del archivo de configuración se busca los paquetes no disponibles y se borran.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/home/cidte/oe-repo/oe-core/../meta-fsl-arm \
/home/cidte/oe-repo/oe-core/../meta-fsl-arm-extra \
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Una vez hecha la modificación, se ejecuta nuevamente el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;bitbake&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bitbake gnuradio-dev-image

Parsing recipes: 100% |#######################################| Time: 00:00:14
Parsing of 1871 .bb files complete (0 cached, 1871 parsed). 2377 targets, 194 skipped, 0 masked, 0 errors.
WARNING: No bb files matched BBFILE_PATTERN_ettus-e100 '^/home/cidte/oe-repo/oe-core/../meta-ettus/e100-bsp/'
NOTE: Resolving any missing task queue dependencies
NOTE: multiple providers are available for jpeg (jpeg, libjpeg-turbo)
NOTE: consider defining a PREFERRED_PROVIDER entry to match jpeg
NOTE: multiple providers are available for jpeg-native (jpeg-native, libjpeg-turbo-native)
NOTE: consider defining a PREFERRED_PROVIDER entry to match jpeg-native

Build Configuration:
BB_VERSION        = &quot;1.26.0&quot;
BUILD_SYS         = &quot;x86_64-linux&quot;
NATIVELSBSTRING   = &quot;elementary-OS-0.3.1&quot;
TARGET_SYS        = &quot;arm-oe-linux-gnueabi&quot;
MACHINE           = &quot;zedboard-zynq7&quot;
DISTRO            = &quot;nodistro&quot;
DISTRO_VERSION    = &quot;nodistro.0&quot;
TUNE_FEATURES     = &quot;arm armv7a vfp neon callconvention-hard&quot;
TARGET_FPU        = &quot;vfp-neon&quot;
meta              = &quot;(nobranch):f0873b83d693af4a103999160d67fcf25c7eedc1&quot;
e100-bsp          
e300-bsp          
common            = &quot;(nobranch):eed1cc7bd61aaefc711237f5952faa23f859454d&quot;
meta-xilinx       = &quot;(nobranch):13779b9254bab450875a60ed8f21edd0e8876a71&quot;
meta-oe           
meta-networking   
meta-filesystems  
meta-python       = &quot;(nobranch):df2f700d66bace65f5d802225232d01cf511fe81&quot;
meta-sdr          = &quot;(nobranch):033049a3fa7c97dbe57eaaa54b84b05cbdd6484f&quot;
meta-ti           = &quot;(nobranch):2210ae2cdacc22105b76c5fa45957ebec104f1c6&quot;

NOTE: Preparing RunQueue
NOTE: Executing SetScene Tasks
NOTE: Executing RunQueue Tasks
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Copia a memoria SD.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Una vez terminado el proceso de compilación cruzada, el proyecto entrega una serie de archivos que son el sistema operativo embebido en la siguiente ubicación.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cd /&amp;lt;ruta-instalación-repo&amp;gt;/oe-repo/build/tmp-glibc/deploy/images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Estos archivos deben ser copiados a una memoria SD, para ello es necesario que la memoria tenga dos particiones: una llamada BOOT, fat32, de 40 MB y que sea bootable y la segunda llamada rootfs, ext4 y de tamaño del resto de la memoria. Los archivos que se requieren en la memoria SD en la partición de BOOT son:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cp boot.bin /&amp;lt;ruta-a-memoria-SD&amp;gt;/BOOT
$ cp u-boot.elf /&amp;lt;ruta-a-memoria-SD&amp;gt;/BOOT
$ cp u-boot-dtb.img /&amp;lt;ruta-a-memoria-SD&amp;gt;/BOOT
$ cp uEnv.txt /&amp;lt;ruta-a-memoria-SD&amp;gt;/BOOT
$ cp uImage /&amp;lt;ruta-a-memoria-SD&amp;gt;/BOOT
$ cp zedboard-zynq7.dtb /&amp;lt;ruta-a-memoria-SD&amp;gt;/BOOT
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Los archivos para la partición de rootfs estan en un comprimido, no es necesario que el archivo comprimido sea copiado a la memoria, por lo que se puede extraer directamente&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo tar -C /&amp;lt;ruta-a-memoria-SD&amp;gt;/rootfs/ -xzpf gnuradio-dev-image-zedboard-zynq7.tar.gz
$ sudo tar -C /&amp;lt;ruta-a-memoria-SD&amp;gt;/rootfs/ -xzpf modules-zedboard-zynq7.tgz
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Cabe mencionar que puede ser posible que el sistema no arranque debido a problemas con el archivo &lt;code class=&quot;highlighter-rouge&quot;&gt;boot.bin&lt;/code&gt;, para solucionar el problema sólo hay que sustituirlo por uno que funcione correctamente o en su defecto crear uno utilizando las herramientas de ISE y SDK.&lt;/p&gt;

&lt;p&gt;Con respecto a los archivos utilizados en &lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs&lt;/code&gt;, no existe ningún problema si son sustituidos utilizando archivos de &lt;code class=&quot;highlighter-rouge&quot;&gt;BOOT&lt;/code&gt; de otra versión, ya que los archivos de &lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs&lt;/code&gt; representan el sistema operativo y los archivos de &lt;code class=&quot;highlighter-rouge&quot;&gt;BOOT&lt;/code&gt; la plataforma de hardware.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;SDK.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Adicionalmente, el proyecto permite obtener el SDK del sistema embebido.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ export MACHINE=&quot;zedboard-zynq7&quot;
$ bitbake -c populate_sdk gnuradio-dev-image

$ ls tmp-glibc/deploy/sdk/
$ sudo sh tmp-glibc/deploy/sdk/oecore-x86_64-armv7ahf-vfp-neon-toolchain-nodistro.0.sh
$ . /usr/local/oecore-x86_64/environment-setup-armv7ahf-vfp-neon-oe-linux-gnueabi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Comunicación con tarjeta Zedboard a través de puerto serial.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El puerto &lt;code class=&quot;highlighter-rouge&quot;&gt;UART&lt;/code&gt; de la tarjeta Zedboard es un puerto USB que se comunica de modo serial con la computadora, al momento de encender la tarjeta y estando conectada con la computadora por el puerto USB, se teclea el siguiente comando para buscar el puerto serial.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ dmesg | grep tty
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Existen diversas maneras de llamar al puerto serial, entre ellas:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/dev/ttyS0 (puerto serial)
/dev/ttyUSB0 (serial sobre USB)
/dev/ttyACM0 (serial sobre USB)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Una vez indentificado, se procede a comunicar con la tarjeta, en linux se puede utilizar el paquete &lt;code class=&quot;highlighter-rouge&quot;&gt;screen&lt;/code&gt; para realizar la comunicación serial.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install screen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ya instalado el paquete, se procede a realizar el enlace a través del puerto serial.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ screen /dev/ttyACM0 115200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finalmente, se procede a encender la tarjeta Zedboard, en caso de que no arranque, desde el puerto serial se ejecuta:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; env default -a
&amp;gt; env save
&amp;gt; reset
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Para entrar a esta consola se tiene que evitar el autoboot de la tarjeta.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Acceso SSH con X11Forwarding.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Para habilitar la conexión SSH con X11Forwarding, desde el puerto serial hay que modificar el archivo:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vi /etc/ssh/sshd_config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Descomentar &lt;code class=&quot;highlighter-rouge&quot;&gt;X11Forwarding no&lt;/code&gt; y poner &lt;code class=&quot;highlighter-rouge&quot;&gt;X11Forwarding yes&lt;/code&gt;. En caso de no conocer como funciona el editor &lt;code class=&quot;highlighter-rouge&quot;&gt;vi&lt;/code&gt; se puede buscar los comandos básicos en Internet.&lt;/p&gt;

&lt;p&gt;Reiniciar el servicio con el comando&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /etc/init.d/sshd restart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;De este modo, queda habilitado &lt;code class=&quot;highlighter-rouge&quot;&gt;X11Forwarding&lt;/code&gt; en los enlaces SSH, sin embargo es necesario indicar &lt;code class=&quot;highlighter-rouge&quot;&gt;-X&lt;/code&gt; en la configuración de la conexión.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fijar contraseña al usuario root.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;La contraseña de root se fija desde la terminal con el siguiente comando&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# passwd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Apagado remoto de la tarjeta Zedboard.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Para apagar remotamente la tarjeta Zedboard sin dañar el sistema embebido es necesario teclear en la terminal de enlace remoto el comando.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# shutdown -h now
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Conclusión.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;El desarrollo de un sistema embebido a través de compilación cruzada puede resultar bastante complejo, pero la ventaja principal es que solo se requiere realizar una vez y los archivos generados pueden ser distribuidos libremente para la tarjeta para la cual fue diseñada. Así también, debido a que el proyecto de GNU Radio se basa en yocto y openembedded, es viable agregar otros proyectos a través de bblayers.&lt;/p&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name></name></author><summary type="html">El uso de sistemas embebidos se ha popularizado y beneficiado por las nuevas tecnologías, ya que ahora permiten implementar sistemas que no solo controlen de un modo básico y simple un dispositivo, sino que pueden formar parte de un ecosistema que incluya conectividad a Internet y por lo tanto monitoreo y control remoto. Adicionalmente, tendencias como el radio definido por software (SDR) han integrado a sus desarrollos la implementación en sistemas embebidos lo que permite el desarrollo de un sistema de comunicación completo en un ambiente embebido, disminuyendo costos y proporcionando portatibilidad.</summary></entry><entry><title type="html">Instalación de Xillinux en tarjetas ZedBoard</title><link href="http://viktorivan.github.io/xillinux/embedded/zedboard/2015/11/28/instalacion-de-xillinux-en-tarjetas-zedboard.html" rel="alternate" type="text/html" title="Instalación de Xillinux en tarjetas ZedBoard" /><published>2015-11-28T19:21:01+00:00</published><updated>2015-11-28T19:21:01+00:00</updated><id>http://viktorivan.github.io/xillinux/embedded/zedboard/2015/11/28/instalacion-de-xillinux-en-tarjetas-zedboard</id><content type="html" xml:base="http://viktorivan.github.io/xillinux/embedded/zedboard/2015/11/28/instalacion-de-xillinux-en-tarjetas-zedboard.html">&lt;p&gt;En fechas recientes se ha vuelto popular el uso de sistemas reducidos que permiten instalar sistemas operativos en modo embebido, un ejemplo es &lt;a href=&quot;https://www.raspberrypi.org&quot;&gt;raspberry pi&lt;/a&gt;, el cuál es un ecosistema que presenta varios &lt;a href=&quot;https://www.raspberrypi.org/downloads/&quot;&gt;sistemas operativos embebidos&lt;/a&gt;  de libre distribución. Así mismo existen otros ecosistemas orientados a propósitos mas específicos, tales como &lt;a href=&quot;http://zedboard.org&quot;&gt;Zedboard&lt;/a&gt;, donde presentan varias alternativas de hardware de acuerdo a los requerimientos del usuario. Estas plataformas son basadas en Linux, por lo que proyectos como &lt;a href=&quot;http://xillybus.com/xillinux&quot;&gt;Xillinux&lt;/a&gt; aprovechan al máximo las características del hardware y en conjunto con &lt;a href=&quot;http://www.xilinx.com/products/design-tools/vivado.html&quot;&gt;VIVADO&lt;/a&gt; incluyen una plataforma de hardware adaptable a la tarjeta seleccionada.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instalación.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;En la página de &lt;a href=&quot;http://xillybus.com/xillinux&quot;&gt;Xillinux&lt;/a&gt; se indica donde descargar el sistema operativo, a diferencia de raspberry, es necesario realizar unos pasos antes de copiar los archivos a una memoria SD, ya que es necesario crear el archivo .bit que representa la plataforma de hardware de Zedboard.&lt;/p&gt;

&lt;p&gt;De acuerdo al &lt;a href=&quot;http://xillybus.com/downloads/doc/xillybus_getting_started_zynq.pdf&quot;&gt;manual&lt;/a&gt;, es necesario crear antes el procesador &lt;code class=&quot;highlighter-rouge&quot;&gt;netlist&lt;/code&gt; y generar los IP cores de Xilinx con ayuda de VIVADO.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Copia a SD.&lt;/em&gt;
Una vez teniendo el archivo generado se procede a la copia del sistema operativo a la memoria SD.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Para instalar Xillinux en la memoria SD, primero localizar en donde esta montada.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ lsblk
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Copiar la imagen de Xillinux en memoria SD.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo dd if=xillinux-1.3.img of=/dev/sdX bs=512
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;Comprobar que la copia quedo correcta y esperar como respuesta EOF.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo cmp xillinux-1.3.img /dev/sdX
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Desmontar o expulsar la memoria y volver a insertar para ver las particiones nuevas.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Copiar los archivos de bootfiles en la particion uno, por lo general es la menor.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Con gparted ajustar la segunda particion al tamaño de la memoria.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Insertar memoria en Zedboard, en caso de no arrancar presionar el micro switch PS-RST.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Para comunicarse con la Zedboard a traves del puerto serial.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo screen /dev/ttyACM0 115200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;En caso de no tener el programa screen.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ sudo apt-get install screen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;En caso de que el sistema operativo de la Zedboard no cargue, desde una terminal con puerto serial se reinicia la tarjeta para entrar al u-boot presionando PS-RST y cuando indique presiobar cualquier tecla para evitar arranque. Una vez en u-boot se teclean los siguientes comandos:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; env default -a
&amp;gt; env save
&amp;gt; reset
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;@viktor_ivan&lt;/p&gt;</content><author><name></name></author><summary type="html">En fechas recientes se ha vuelto popular el uso de sistemas reducidos que permiten instalar sistemas operativos en modo embebido, un ejemplo es raspberry pi, el cuál es un ecosistema que presenta varios sistemas operativos embebidos de libre distribución. Así mismo existen otros ecosistemas orientados a propósitos mas específicos, tales como Zedboard, donde presentan varias alternativas de hardware de acuerdo a los requerimientos del usuario. Estas plataformas son basadas en Linux, por lo que proyectos como Xillinux aprovechan al máximo las características del hardware y en conjunto con VIVADO incluyen una plataforma de hardware adaptable a la tarjeta seleccionada.</summary></entry></feed>